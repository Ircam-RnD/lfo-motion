<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Documentation - Source: operator/MeanCrossingRate.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link type="text/css" rel="stylesheet" href="styles/overrides.css">
</head>

<body>

<div id="main">

    <!-- if home page assume a title is already present in README -->
    
    <h1 class="page-title">Source: operator/MeanCrossingRate.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { BaseLfo } from 'waves-lfo/core';
import MeanCrossingRateBase from './MeanCrossingRateBase';

const parameters = {
  noiseThreshold: {
    type: 'float',
    default: 0.1,
  },
  frameSize: {
    type: 'integer',
    default: 512,
    metas: { kind: 'static' },
  },
  hopSize: { // should be nullable
    type: 'integer',
    default: null,
    nullable: true,
    metas: { kind: 'static' },
  },
  // centeredTimeTags: {
  //   type: 'boolean',
  //   default: false,
  // }
}

/**
 * Mean Crossing Rate operator : estimates energy, frequency and periodicity of
 * a (n-dimension) signal, either on an input stream of signal frames, or by
 * using its own sliding window on an input stream of vectors.
 *
 * The mean is estimated on each new analyzed window using the following equation :
 * `mean = min + (max - min) * 0.5;`
 *
 * @param {Object} options - Override default options
 * @param {Number} [options.noiseThreshold=0.1] - Threshold added to the mean to
 *  avoid confusion between noise and real signal.
 * @param {Number} [options.frameSize=512] - Size of the internal sliding window.
 * @param {Number} [options.hopSize=null] - Number of samples between
 *  two computations on the internal sliding window.
 */

// We don't use centered time tags for signal input, as we don't know if it's
// already been done by a previous slicer.
// So we don't implement it for now.
// would be :
// @param {Boolean} [options.centeredTimeTags=false] - Move the time tag to the
// middle of the frame.

class MeanCrossingRate extends BaseLfo {
  constructor(options = {}) {
    super(parameters, options);

    this._mcrs = [];
  }

  /** @private */
  onParamUpdate(name, value, metas) {
    if (!this.params.hopSize) {
      this.params.set('hopSize', frameSize);
    }
  }

  /** @private */
  processStreamParams(prevStreamParams = {}) {
    this.prepareStreamParams(prevStreamParams);

    // TODO : set output samplerate according to input samplerate + hopSize (?)
    this._mcrs = [];

    for (let i = 0; i &lt; prevStreamParams.frameSize; i++) {
      this._mcrs.push(new MeanCrossingRateBase({
        noiseThreshold: this.params.get('noiseThreshold'),
        frameSize: this.params.get('frameSize'),
        hopSize: this.params.get('hopSize'),
        sampleRate: prevStreamParams.sourceSampleRate,
      }));
    }

    // if input frames are of type "signal", input dimension is 1
    this.streamParams.frameSize = 2;//3;
    this.streamParams.description = [ /*'energy',*/ 'frequency', 'periodicity' ];
    this._mcrs.push(new MeanCrossingRateBase({
      noiseThreshold: this.params.get('noiseThreshold'),
      frameSize: this.params.get('frameSize'),
      hopSize: this.params.get('hopSize'),
      sampleRate: prevStreamParams.sourceSampleRate,
    }));

    // otherwise we have to parallelize :
    if (this.streamParams.frameType === 'vector') {
      this.streamParams.frameSize *= prevStreamParams.frameSize;

      for (let i = 1; i &lt; prevStreamParams.frameSize; i++) {
        this.streamParams.description.concat(this.streamParams.description);
        this._mcrs.push(new MeanCrossingRateBase({
          noiseThreshold: this.params.get('noiseThreshold'),
          frameSize: this.params.get('frameSize'),
          hopSize: this.params.get('hopSize'),
          sampleRate: prevStreamParams.sourceSampleRate,
        }));
      }
    }

    // not divided by hopSize, we just duplicate frames between.
    // this means we can comment the following line :
    // this.streamParams.frameRate = prevStreamParams.sourceSampleRate;

    this.propagateStreamParams();
  }

  /** @private */
  processVector(frame) {
    const inData = frame.data;
    const outData = this.frame.data;

    for (let i = 0; i &lt; this._mcrs.length; i++) {
      const r = this._mcrs[i].process(inData[i]);
      outData[i * 3]      = r.frequency;
      outData[i * 3 + 1]  = r.periodicity;
    }
  }

  /** @private */
  processSignal(frame) {
    this.frame.data = this._mcrs[0].processFrame(frame.data);
  }
}

export default MeanCrossingRate;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Intensity.html">Intensity</a></li><li><a href="MeanCrossingRate.html">MeanCrossingRate</a></li><li><a href="MotionFeatures.html">MotionFeatures</a></li><li><a href="MotionInput.html">MotionInput</a></li><li><a href="Orientation.html">Orientation</a></li><li><a href="Sampler.html">Sampler</a></li><li><a href="StillAutoTrigger.html">StillAutoTrigger</a></li></ul><h3>Global</h3><ul><li><a href="global.html#definitions">definitions</a></li></ul>
</nav>

<br class="clear">

<footer>
    
        Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.4</a> on Mon Oct 02 2017 18:28:42 GMT+0200 (CEST)
    
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
